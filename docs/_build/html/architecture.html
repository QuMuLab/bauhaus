
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Architecture Design &#8212; bauhaus 1.0.0dev documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Module Reference" href="bauhaus.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="architecture-design">
<h1>Architecture Design<a class="headerlink" href="#architecture-design" title="Permalink to this headline">¶</a></h1>
<p>Author: Karishma Daga</p>
<p>Github: <a class="reference external" href="https://github.com/QuMuLab/bauhaus">https://github.com/QuMuLab/bauhaus</a></p>
<div class="section" id="what-is-bauhaus">
<h2>What is bauhaus?<a class="headerlink" href="#what-is-bauhaus" title="Permalink to this headline">¶</a></h2>
<p>Bauhaus is a library for building logical theories on the fly with Python.
The library allows people to take advantage of object-oriented principles to build theories about real-life
relationships and systems without the hassle of repetitive code.</p>
<p>It is a companion library to <code class="docutils literal notranslate"><span class="pre">nnf</span></code>, a library for building and manipulating logical NNF sentences.</p>
</div>
<div class="section" id="how-bauhaus-works">
<h2>How bauhaus works<a class="headerlink" href="#how-bauhaus-works" title="Permalink to this headline">¶</a></h2>
<p>Bauhaus was designed to be simple and easy to work with for creating logical theories from object-oriented code.
Logical theories consist of propositional variables that are structured into constraints to represent relationships.
To find models that satisfy these formulas using an SAT solver, we represent the constraints in conjunctive normal
form (CNF).</p>
<p>The Bauhaus library can be broken down into three parts:</p>
<ul class="simple">
<li><p>Encoding objects</p></li>
<li><p>Creating propositions and constraints</p></li>
<li><p>Building the theory</p></li>
</ul>
<p>Encoding objects store a theory’s propositions and constraints, and once you’re satisfied (haha),
you can compile the Encoding object into a conjunctive or negation normal theory.</p>
<p>It’s possible to build multiple theories at the same time by passing different
Encoding objects as parameters to proposition and constraint decorators and functions.</p>
</div>
<div class="section" id="design-decisions">
<h2>Design decisions<a class="headerlink" href="#design-decisions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="keep-the-interface-simple">
<h3>Keep the interface simple<a class="headerlink" href="#keep-the-interface-simple" title="Permalink to this headline">¶</a></h3>
<p>Keeping the user flow simple and expressive was important.
You only have to interact with three objects or functions
to be able to build complex logical theories.</p>
</div>
<div class="section" id="build-constraints-dynamically">
<h3>Build constraints dynamically<a class="headerlink" href="#build-constraints-dynamically" title="Permalink to this headline">¶</a></h3>
<p>Building a constraint dynamically means that we store
information about a constraint and wait until a user hits
<code class="docutils literal notranslate"><span class="pre">compile()</span></code> on an Encoding object to build the constraint.
The benefit is in reducing redundant clauses and complexity
in the software. It also makes it simpler to debug as someone
can clearly catch when and where an error occurs.</p>
</div>
<div class="section" id="theory-introspection">
<h3>Theory introspection<a class="headerlink" href="#theory-introspection" title="Permalink to this headline">¶</a></h3>
<p>Theories can grow incredibly large, so it’s important
to be able to understand where a clause or constraint came from.
Introspection for bauhaus allows a user to view the per-instance
constraints and the final constraint that was added to the theory.</p>
</div>
</div>
<div class="section" id="system-overview">
<h2>System Overview<a class="headerlink" href="#system-overview" title="Permalink to this headline">¶</a></h2>
<div class="section" id="encoding-class">
<h3>Encoding Class<a class="headerlink" href="#encoding-class" title="Permalink to this headline">¶</a></h3>
<p>An <code class="docutils literal notranslate"><span class="pre">Encoding</span></code> object has two public attributes: <code class="docutils literal notranslate"><span class="pre">propositions</span></code> and <code class="docutils literal notranslate"><span class="pre">constraints</span></code>.</p>
<p>Each time a class decorated with <code class="docutils literal notranslate"><span class="pre">&#64;proposition</span></code> is instantiated, we need to
store a reference to the object in <code class="docutils literal notranslate"><span class="pre">Encoding.propositions</span></code> so that we can
build constraints associated with that object or class later.</p>
<p><strong>Storing Instances and Garbage Collection</strong></p>
<p>As Python doesn’t have a builtin method for storing instances of classes
and we wanted to store propositional variables (instantiated objects)
in such a way that if they are not referenced anymore, we don’t want our
reference in <code class="docutils literal notranslate"><span class="pre">Encoding.propositions</span></code> to keep the object from being garbage collected.
The object could also not be relevant anymore to a user as well, which could
result in incorrect constraints if it’s kept in propositions.</p>
<p>The solution to this is to use WeakValueDictionaries to weakly reference the
<code class="docutils literal notranslate"><span class="pre">id</span></code> of an object to the object. The propositions attribute looks like,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>encoding.propositions = {classname -&gt; WeakValueDictionary(id -&gt; obj,
                                                          id -&gt; obj,
                                                          …
                                                          id -&gt; obj)
</pre></div>
</div>
</div>
<div class="section" id="proposition-decorator">
<h3><code class="docutils literal notranslate"><span class="pre">&#64;proposition</span></code> decorator<a class="headerlink" href="#proposition-decorator" title="Permalink to this headline">¶</a></h3>
<p>The proposition decorator wraps a class such that each time
the class is instantiated, it adds the instance to the given
Encoding’s proposition attribute.</p>
</div>
<div class="section" id="constraint-class">
<h3>Constraint Class<a class="headerlink" href="#constraint-class" title="Permalink to this headline">¶</a></h3>
<p><strong>Creating Constraints</strong></p>
<p>A user can create constraints by decorating a class or method or by
calling a function. Since we’re not compiling the constraint right away, the point
of both the decorators and functions are to create a ConstraintBuilder object
which will store the user-given information about the constraint.</p>
<p>So, we direct decorator and function calls to their own class methods with the
given parameters to,</p>
<ul class="simple">
<li><p>Build a ConstraintBuilder object</p></li>
<li><p>Store that object in the given Encoding.</p></li>
<li><p>In the case of constraint decorators, we are wrapping a <code class="docutils literal notranslate"><span class="pre">&#64;proposition</span></code> decorator, so we must instantiate and return it so that a user can apply as many constraints as they’d like to a class</p></li>
</ul>
<p><strong>Building Constraints</strong></p>
<p>Once a user hits compile on an Encoding, we iterate over each ConstraintBuilder
object in the Encoding’s constraints attribute.</p>
<p>Building a constraint is a two step process:</p>
<ul class="simple">
<li><p>Get the propositional variables</p></li>
<li><p>Construct the constraint</p></li>
</ul>
<p>Both steps are relatively simple.</p>
<p>We check if a ConstraintBuilder was made from a decorator or not. If it was, then the only
variables we need are stored in the Encoding’s propositions attribute.
If it was made from a function call, then we validate and return the user-given
arguments stored in the ConstraintBuilder. A user could have provided
a decorated class or method as an argument.</p>
<p>The only distinct implementation is for implies all, which requires
a left and right side of an implication, so there is a separate
function to retrieve its inputs and store them as a dictionary.</p>
<p>Constructing the constraint involves taking the given propositional
variables and using naive implementations of their SAT encoding constraints,
which were referenced from the following paper:</p>
<p><a class="reference external" href="http://www.cs.cmu.edu/~wklieber/papers/2007_efficient-cnf-encoding-for-selecting-1.pdf">Efficient CNF Encoding</a></p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">bauhaus</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="bauhaus.html">Module Reference</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Architecture Design</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#what-is-bauhaus">What is bauhaus?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-bauhaus-works">How bauhaus works</a></li>
<li class="toctree-l2"><a class="reference internal" href="#design-decisions">Design decisions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#system-overview">System Overview</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="bauhaus.html" title="previous chapter">Module Reference</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Karishma Daga, Christian Muise.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/architecture.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>